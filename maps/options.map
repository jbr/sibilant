{"version":3,"sources":["include/functional.sibilant","src/macros/lambda.sibilant","src/macros/loops.sibilant","src/macros/predicates.sibilant","src/macros/flow-control.sibilant","src/macros/math.sibilant","src/macros/lists.sibilant","src/macros/hash.sibilant","src/macros/pipe.sibilant","src/options.sibilant","src/macros/variables.sibilant","src/macros/regex.sibilant","src/macros/misc.sibilant"],"names":[],"mappings":"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","sourcesContent":["(def bulk-map (arr fn)\n  (var index 0\n          group-size fn.length\n          ret-arr [])\n\n  (while (< index arr.length)\n    (.push ret-arr\n          (apply fn (send arr slice\n                          index (+ index group-size))))\n    (incr-by index group-size))\n  ret-arr)\n\n(def inject (start items fn)\n     (if (list? items)\n         (items.reduce fn start)\n         start))\n\n(def map (items fn)\n     (if (list? items)\n         (items.map fn)\n         []))\n\n(def select (items fn)\n     (if (list? items)\n         (items.filter fn)\n         []))\n\n(def detect (items fn)\n     (when (list? items)\n         (items.find fn)))\n\n(def all? (items fn)\n     (when (list? items)\n           (items.every fn)))\n\n(def none? (items fn)\n     (when (list? items)\n           (not (items.some fn))))\n\n(def any? (items fn)\n     (when (list? items)\n           (items.some fn)))\n\n(def reject (items fn)\n  (select items (#> (not (apply fn arguments)))))\n\n\n(def compact (arr)\n     (select arr (#(item)\n                   (and\n                    (!= null item)\n                    (!= false item)\n                    (defined? item)))))\n\n(def unique (arr)\n     (inject [] arr\n             (#(coll item)\n               (if (includes? coll item)\n                   coll\n                   (coll.concat [item])))))\n\n\n(def interleave (glue arr)\n     (when (and (string? arr) (list? glue))\n           (var temp glue)\n           (assign glue arr\n                   arr temp))\n     \n     (if (list? glue) (inject [] arr\n             (#(collector item index)\n               (collector.concat [item (get glue index)])))\n\n         \n     (inject [(first arr)] (rest arr)\n             (#(collector item index) (collector.concat [glue item])))))\n\n\n(def flatten (items predicate)\n     (if (list? items)\n         (inject [] items\n                 (#(collector item)\n                   (if (or (not predicate) (predicate item))\n                       [ ...collector\n                         ...(if (list? item) (flatten item predicate) item) ]\n                       collector)))\n\n         (or (not predicate) (predicate items)) [items]\n\n         []))\n\n(def flat-compact (items)\n     (flatten items (#(item)\n                      (and\n                       (!= null item)\n                       (!= false item)\n                       (defined? item)))))\n\n(def recurse-map (item fn)\n     (if (list? item) (map item (#(subitem) (recurse-map subitem fn)))\n         (fn item)))\n\n(def pluck (items attribute)\n     (map items (#(item) (get item attribute))))\n\n(def merge-into (into from)\n     (Object.assign into from))\n\n(def clone (object)\n     (Object.assign {} object))\n\n(def values (object)\n     (|> object keys (map (#> (get object #0)))))\n\n(def map-values (object fn)\n     (inject {} (keys object)\n             (#(collector key index)\n               (set collector key (fn (get object key) key))\n               collector)))\n\n(def merge-with (into from)\n     (Object.assign {} into from))\n","(namespace core)\n\n(docs \"Defines a lambda/function/closure in Sibilant. Equivalent to\nthe `function` keyword in JavaScript. Most of the time `args` is a\nparen-wrapped list of arguments, which can include one triple-dotted\nsplat in the terminal position.  The last expression of `body` will be\nreturned. Aliased as `#`, as shown in examples.\"\n      tags [ functions language ]\n      examples [ (lambda (a b c) (|> a (+ b) (/ c)))\n(lambda (a b ...numbers)\n        (console.log (\"a: \"a\", b: \"b\"\"))\n        (numbers.map (#-> (+ 10))))\n(#({ destructured-object }) (destructured-object))\n(#([ one two three ]) { one& two& three& })\n(|> document.body\n    (.add-event-listener\n     (#(event)\n       (console.log (\"click at point (\"event.x\",\"event.y\")\"))\n       (event.prevent-default)))) ])\n\n      \n\n(macro lambda (args-or-options ...body)\n       (debug! 3 args-or-options)\n       (var args (or args-or-options.args args-or-options)\n            body (or args-or-options.body body)\n            node (or args-or-options.node this)\n            args (if (node? args 'expression 'bracket) args.contents\n                     (and (node? args) (empty? body)) (do (assign body [ args ]) [])\n                     (node? args 'brace) [ args ]\n                     args)\n            name (when args-or-options.name\n                       (|> args-or-options.name\n                           transpile\n                           output-formatter\n                           (replace-all \"\\\\W+\" \"$\")\n                           (.concat \"$\")))\n            rest (detect args (#-> (node? 'dots)))\n\n            destructured-args (map args (#(arg)\n                                          (if (node? arg 'bracket 'brace)\n                                              (do (var arg-name (generate-symbol (make-symbol-clue arg)))\n                                                  { arg-name &\n                                                    destructured-pair [ arg arg-name ] })\n                                              { arg-name arg })))\n\n            destructured-statements (|> [ (when (exists? rest) [ rest `(Array.prototype.slice.call arguments @(- args.length 1)) ])\n                                          ...(map destructured-args (#-> (get 'destructured-pair))) ]\n                                        flat-compact))\n\n       (assign node (detect\n                     [ node args-or-options.name args (first body) ]\n                     (#(n) (and (node? n) (get n 'file)))))\n\n\n       [\"(function\" (if name (\" \" name) \"\") \"(\"\n         (interleave \", \" (map destructured-args (#-> (get 'arg-name)))) \") {\"\n         (when (and sibilant.state.function-comments (or name node))\n               (indent [\"/*\"\n                         (when name (\" \" (sibilant.pretty-print args-or-options.name false)))\n                         (when node (\" \" node.file \":\" node.line \":\" node.col))\n                         \" */\"]))\n         (when destructured-statements.length (indent `(var ...@destructured-statements)))\n         (indent (apply ^do body))\n         \"})\"])\n\n(alias-macro lambda #)\n(docs \"most often called as its alias, `#>`, thunk creates a function\nwith no named arguments. To refer to arguments anonymously, use #n,\nsuch as #0 for the first argument.\"\n      tags [functions language]\n      examples: [ (.map [ 1 2 3 ] (#> (+ 1 #0)))\n                  (window.set-timeout (#> (console.log 'here)) 10) ])\n(macro thunk (...body)\n       (var node this\n            lambda-options { node node args [] })\n\n       (when (not (node? (first body)))\n             (merge-into lambda-options (first body))\n             (assign body (rest body)))\n\n       '(lambda @lambda-options\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro return (token)\n     (when sibilant.debug (console.log \"returning \" (prettify token)))\n     (var default-return (as-statement [\"return \" (transpile token)]))\n     (if (and token token.contents token.contents.length)\n         (switch (get (first token.contents) 'token)\n                 (('return 'throw 'do) (transpile token))\n\n                 ('delete\n                  (var delete-macro (get macros 'delete))\n                  (if (< token.contents.length 3) default-return\n                      [ (as-statement (apply delete-macro (token.contents.slice 1 -1)))\n                        \"\\nreturn \"\n                        (as-statement (call delete-macro (last token.contents)))]))\n\n                 ('def\n                  [ (transpile token) \"\\n\" (^return (second token.contents)) ])\n\n                 ('assign\n                  (if (< token.contents.length 4) default-return\n                      (do\n                       (var result (clone (transpile token)))\n                       (set result 'contents [ ...(result.contents.slice 0 -4)\n                                               \"return \"\n                                               ...(result.contents.slice -4) ])\n                       result)))\n\n                 ('var\n                  [ (transpile token) \"\\n\" (^return (if (even? token.contents.length)\n                                                                 (last token.contents)\n                                                                 (first (token.contents.slice -2))))])\n\n                 ('set\n                  (if (< token.contents.length 5) default-return\n                      (do\n                       (var obj (second token.contents)\n                            non-return-part (token.contents.slice 2 (- token.contents.length 2))\n                            return-part (token.contents.slice -2))\n                       (non-return-part.unshift obj)\n                       (return-part.unshift obj)\n                       [ (^set ...non-return-part)\n                         \"\\nreturn \"\n                         (^set ...return-part)])))\n\n                 (default default-return))\n         default-return))\n\n\n(macro do (...body)\n     (if (= 1 body.length)\n         (^return (first body))\n\n         body.length\n         [\n          (|> body\n              (.slice 0 -1)\n              (map (#-> as-statement))\n              (interleave \"\\n\"))\n           \"\\n\"\n           (^return (last body))\n           ]\n         \n         \"\"))\n\n\n(docs \"defines a function in the local scope. `name` is the\nvariable name that the function will be stored as.  Note that sibilant\ndoes *not* support hoisting. `args` is a paren-wrapped list of\narguments, as shown in the examples.  `body` can be any number of\nstatements, the last of which will be the return value of the\nfunction.\"\n      examples [ (def square (x) (* x x)) ]\n      tags [ language functions ])\n\n(macro def (name args ...body)\n       (var node this)\n       (when (node? name 'expression)\n             (assign body [ args ...body ]\n                     args (merge-with name { contents (rest name.contents)})\n                     name (first name.contents)))\n\n                     \n     (if (undefined? name) (error \"invalid function definition. missing name.\")\n         (undefined? args) (error \"invalid function definition. missing arguments or return value.\"))\n\n     (sibilant.docs.record 'function (first sibilant.macros.search-path) name node)\n\n     (if (match? (regex \"\\\\.\") (|> name transpile output-formatter))\n         `(assign @name (lambda @{ name& args& node& body& }))\n         `(var @name (lambda @{ name& args& node& body& }))))\n\n\n\n(docs \"This is the macro that is executed when a function is the first\nelement in an expression. Assuming that there is no macro named\n`a`, `(a b c)` internatlly compiles to `(call a b c)`. splats (`...`)\ncan be used in function calls.\"\n      examples [ (call a b c) (call a b ...c) (call a ...args) ]\n      tags [ functions language ])\n\n(macro call (fn-name ...args)\n     (if (any? args (#> (node? #0 'dots)))\n           (macros.apply fn-name (macros.list ...args))\n           [ (transpile fn-name)\n                   \"(\" (interleave \", \" (map args transpile)) \")\" ]))\n(docs \"calls the `method` on `object` as a function with `args` as the arguments\"\n      tags [ functions ]\n      example (send object method first-argument second-argument third-argument))\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n\n\n\n\n(docs \"calls the function `fn` with arguments passed as an array in `arglist`\"\n      tags [functions]\n      example (apply my-function [ first-arg second-arg third-arg ]))\n\n(macro apply (fn arglist)\n       '(.apply @fn this @arglist))\n\n(docs \"executes the `body` inside of a self-executing function. The\nlast statement/expression of the body is returned.\"\n      tags [functions]\n      examples [(scoped true) (scoped (var a 1) (+ a 2))])\n(macro scoped (...body)\n       '(.call (lambda @{node this args []} ...@body) this))\n\n\n(macro *scoped-without-return (...body)\n       [\"(function() {\" (indent ...body) \"}).call(this)\"])\n\n\n(macro *scoped-without-source (...body)\n       `(*scoped-without-return (do ...@body)))\n\n(docs \"transforms function arguments into an array, using the Array prototype's slice\"\n      tags [functions]\n      example (arguments))\n(macro arguments (...args)\n       `(Array.prototype.slice.call arguments ...@args))\n\n\n(docs \"`get`s the argument at `index` in the current function context. Inside of a `thunk` (`#>`), this can be abbreviated with `#n`, where `n` is the argument index.\"\n      tags [functions]\n      example (argument 3))\n(macro argument (index)\n       '(get arguments @index))\n","(namespace core)\n\n(docs \"evaluates the `body` as long as `condition` is truthy,\nreturning the value of the last expression in `block` when `condition`\nceases to be truthy. See also `until`\"\n      tags [loops flow-control]\n      example: (while (> 5 i) (console.log i) (decr i)))\n(macro while (condition ...body)\n       (var symbol (generate-symbol 'while))\n       '(*scoped-without-source\n         (var @symbol)\n         @{ type 'output\n               contents [\"while (\" (transpile condition) \") {\"\n                          (indent '(assign @symbol (*scoped-without-source ...@body)))\n                          \"}\"] }\n         @symbol))\n\n\n\n\n(docs \"evaluates the `body` as long as `condition` is falsy,\nreturning the value of the last expression in `block` when `condition`\nceases to be falsy. See also `while`\"\n      tags [loops flow-control]\n      example: (until (< 5 i) (console.log i) (incr i)))\n\n(macro until (condition ...body)\n       '(while (not @condition) ...@body))\n\n\n","(namespace core)\n(docs \"predicate to test for equality with zero\"\n      tags [numbers]\n      example: (zero? n))\n(macro zero? (item) '(= @item 0))\n\n\n(docs \"returns true if the array `arr` has a length of zero\"\n      tags [arrays collections]\n      example: (empty? []))\n(macro empty? (arr)\n       `(= 0 (length @arr)))\n\n\n(docs \"returns true if `number` is not divisible by 2\"\n      tags [numbers]\n      example (odd? 5))\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n\n(docs \"returns true if `number` is divisible by 2 with no remainder\"\n      tags [numbers]\n      example (even? 10))\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n(docs \"returns true if all of the `things` are javascript strings\"\n      tags [strings type]\n      examples: [ (string? test-object) (string? 'yes 'yes 'yes) ])\n(macro string? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'string)))))\n\n\n(docs \"returns true if all of the `things` are functions\"\n      tags [functions type]\n      examples: [ (function? fn) (function? err cb) ])\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(docs \"returns true if all of the `things` are undefined, as tested\nwith `typeof`, not equality with literal undefined. This is the\ninverse of `defined?`\"\n      tags [type]\n      examples: [ (undefined? argument)\n                  (undefined? 1 2 undefined) ])\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n\n(docs \"returns true if none of the `things` are undefined, as tested\nwith `typeof`. This is the inverse of `undefined?`\"\n      tags [type]\n      examples: [ (defined? variable)\n                  (defined? var1 var2 var3) ])\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n\n\n(docs \"returns true if all of the `things` are numbers, as tested\nwith `typeof`\"\n      tags [numbers type]\n      examples: [ (number? 1) (number? 1 2 3) ])\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n\n(docs \"returns true if `thing` is an array in javascript. aliased as\n`list?`.\"\n      tags [type arrays]\n      example: (array? arr))\n\n(macro array? (thing)\n       `(and\n         @thing\n         (= 'object (typeof @thing))\n         (= 'Array (get @thing 'constructor 'name))))\n(alias-macro array? list?)\n\n\n(docs \"returns true if `thing` is an object that is not an array in javascript. aliased as\n`object?`.\"\n      tags [type objects]\n      example: (object? arr))\n\n(macro hash? (thing)\n       `(and (= 'object (typeof @thing))\n             (!= @thing null)\n             (!= (get @thing 'constructor 'name) 'Array)))\n(alias-macro hash? object?)\n\n\n(docs \"uses the javascript `instanceof` operator to check if `item` is of `type`.\"\n      tags [language type]\n      example (instance-of? (new Date) Date))\n(macro instance-of? (item type)\n       `(parens (transpile item) \" instanceof \" (transpile type)))\n\n\n\n(docs \"similar to the javascript truthiness predicate `as-boolean`, returns true unless the `thing` is undefined or null\"\n      tags [type]\n      example (exists? window))\n(macro exists? (thing)\n       `(and (defined? @thing) (!= @thing null)))\n\n\n(docs \"checks if `object` has property `key`.  returns true or false.\"\n      tags [objects collections]\n      example (has-key? object 'a))\n\n(macro has-key? (object key)\n       `(.has-own-property @object @key))\n\n(docs \"checks if a string is identical to the lower-cased version of itself\"\n      tags [strings]\n      example (lower-case? \"abc\"))\n(macro lower-case? (str)\n       `(and\n         (!= (.to-upper-case @str) @str)\n         (= (.to-lower-case @str) @str)))\n\n\n\n(docs \"checks if a string is identical to the upper-cased version of itself\"\n      tags [strings]\n      example (lower-case? \"abc\"))\n(macro upper-case? (str)\n       `(and\n         (!= (.to-lower-case @str) @str)\n         (= (.to-upper-case @str) @str)))\n","(namespace core)\n\n(docs \"the simplest way to conditionally execute code.\"\n      tags [ conditional flow-control ]\n      example (ternary (< 50 100)\n         \"fifty is less than 100\"\n         \"fifty is more than 100\"))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n\n(docs \"evaluates statements in `body` if `condition` is true. `body`\n      is `scoped` in a self-evaluating function to support having a\n      return value from the if statement.\"\n      tags [ conditional flow-control language ]\n      example: (when (< 3 i) (console.log i) (get arr i)))\n\n(macro when (condition ...body)\n       (^*scoped-without-return\n         \"if (\" @condition \") {\"\n         (indent `(do ...@body))\n         \"}\"))\n\n(docs \"evaluates statements in `body` if `condition` is falsy. `body`\n      is `scoped` in a self-evaluating function to support having a\n      return value from the if statement.\"\n      tags [conditional flow-control]\n      example: (unless (< 3 i) (console.log i) (get arr i)))\n\n(macro unless (condition ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @condition) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"}).call(this)\"])\n\n(docs \"tests any number of `alternating-conditions-and-branches`.  If\n      an odd number of branches are supplied, the final branch is a\n      default else clause.  To evaluate more than one expression as a\n      branch, use the `do` macro, as shown in the examples:\"\n      tags [conditional flow-control]\n      examples [ (if true (console.log 'here))\n                 (if (= 1 arguments.length) (console.log \"one argument\")\n                     (= 'blue favorite-color) (console.log \"blue\")\n                     (assign examples 'difficult))\n                 (if (foo?) (do (a b)\n                                (c))\n                     (bar?) (do (baz)\n                                (wibble))\n                     (do (d e)\n                         (console.log 'default))) ])\n\n\n\n(macro if (...alternating-conditions-and-branches)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map alternating-conditions-and-branches\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"}).call(this)\"])\n","(namespace core)\n\n(docs \"adds `args` using the javascript `+` operator. Since javascript\noverloads this for string concatenation, this macro can be used for\nthis as well.\"\n      tags [ strings numbers ]\n      examples [ (+ 1 2 3) (+ 'hello 'world) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(alias-macro + concat)\n\n\n(docs \"subtracts each subsequent element of `args`\"\n      tags [numbers]\n      examples [ (- 2 1) (- 10 5 1) ])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n\n(docs \"multiplies elements of `args`\"\n      tags [numbers]\n      example (* 3 4 5))\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n\n(docs \"divides each subsequent element of `args`\"\n      tags [numbers]\n      examples [ (/ 1 2)\n                 (/ 1 2 3) ])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n\n(docs \"modulus operator\"\n      tags [numbers]\n      example (mod 10 2))\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n\n(docs \"increments `item` by `increment`\"\n      tags [numbers]\n      example (incr-by n 5))\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(docs \"increments item by 1\",\n      tags [numbers],\n      example (incr i))\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n\n(docs \"decrements item by 1\",\n      tags [numbers],\n      example (decr i))\n(macro decr (item) [\"((\" (transpile item) \")--)\"])\n\n\n(docs \"short circuiting operator returns the first element of `args` that evaluates to be truthy\"\n      tags [ conditional flow-control booleans ]\n      example (or (= 1 2) (string? []) \"one is not two and an array is not a string\"))\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n\n(docs \"returns the last element if all elements of `args` are truthy, or the\nfirst non-truthy element if it exists\"\n      tags [ booleans ]\n      example (and (string? \"string\") (number? 10) (= 1 1)))\n(macro and (...args)\n       (if (= 1 (length args))\n           (transpile (first args))\n           `(parens ...@(interleave \" && \" (map args transpile)))))\n\n(docs \"boolean negation, as determined by javascript truthiness\"\n      tags [booleans]\n      example: (not (string? 1))\n      references: [ \"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\"\n                    \"https://developer.mozilla.org/en-US/docs/Glossary/Falsy\" ])\n(macro not (exp)\n       [\"!\" `(parens @exp) ])\n\n\n\n(docs \"double-negates `expr`, converting it to a boolean\"\n      tags [type booleans]\n      examples: [ (as-boolean 0)\n                  (as-boolean true) ])\n(macro as-boolean (expr)\n       `(parens @\"!!\" (parens @expr)))\n\n(docs \"coerces `expr` to a number.  Currently implemented through the use of Number()\"\n      tags [type numbers]\n      examples: [ (as-number \"0.1\")\n                  (as-number 0.1) ]\n      references: [ \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number\" ])\n(macro as-number (expr) `(Number @expr))\n","(namespace core)\n\n\n(docs \"This is the macro that is called when brackets (`[]`) are\nused. Emits a javascript array literal. Splats (`...`) can be used to\nin-line other arrays.\"\n      tags [arrays collections]\n      examples [ (list 1 2 3 4 5)\n                 [ 'a 'b 'c 'd 'e ]\n                 [ a b ...c d ...e ] ])\n      \n(macro list (...args)\n       (var arg-segments [])\n       (if (empty? args) \"[]\"\n           (do\n            (def simple-list (args)\n                 [\"[ \" (interleave \", \" (map args (#(arg) arg.transpiled))) \" ]\"])\n\n            (args.for-each (#(arg)\n                  (if (node? arg 'dots) (arg-segments.push {transpiled (transpile arg)})\n                   (list? (last arg-segments)) (.push (last arg-segments) { transpiled (transpile arg)})\n                   (arg-segments.push [{transpiled (transpile arg)}]))))\n\n            (assign arg-segments (map arg-segments\n                                      (#(segment)\n                                        (if (list? segment)\n                                            (simple-list segment)\n                                            segment.transpiled))))\n\n            (if (= 1 (length arg-segments))\n                (first arg-segments)\n                [(first arg-segments) \".concat(\" (interleave \", \" (rest arg-segments))\")\"]))))\n\n(docs \"fetches length attribute from `arr`\"\n      tags [ arrays collections ]\n      example (length [ 1 2 3 ]))\n(macro length (arr)\n       '(get @arr 'length))\n\n\n(docs \"`get`s the first element of `arr`\"\n      tags [ arrays collections ]\n      example (first `[ a b c d e ]))\n(macro first (arr) `(get @arr 0))\n\n(docs \"`get`s the second element of `arr`\"\n      tags [ arrays collections ]\n      example (second `[ a b c d e ]))\n(macro second (arr) `(get @arr 1))\n\n(docs \"`get`s the third element of `arr`\"\n      tags [ arrays collections ]\n      example (third `[ a b c d e ]))\n(macro third (arr) `(get @arr 2))\n\n\n(docs \"fetches all but the first item of `arr`\"\n      tags [arrays collections]\n      example (rest [ 1 2 3 ]))\n(macro rest (arr) '(.slice @arr 1))\n\n(docs \"fetches just the last element of `arr` by slicing.\"\n      tags [arrays collections]\n      example (last [ 1 2 3 ]))\n(macro last (arr) '(first (.slice @arr -1)))\n\n\n\n(docs \"builds an array with `first` as the zeroth index and the\nelements provided by array `rest` as the subsequent elements, as\nsiblings with `first`.\"\n      tags [arrays collections deprecated]\n      example (cons 1 [ 2 3 4 ]))\n\n(macro cons (first rest)\n       `(pipe\n         (list @first)\n         (.concat @rest)))\n\n\n(docs \"adds `additional` elements onto the right-side (tail) of `list`. deprecated\"\n      tags [ arrays collections deprecated ]\n      example (append [ 1 2 3 ] 4 5 6))\n(macro append (list ...additional)\n       `(.concat @list (list ...@additional)))\n\n(docs \"iterates over `array`, evaluating `body` once for each value in\n`array`.  If `item` is a literal name, that will be the variable into\nwhich the `array` element is yielded (current value).  If `item` is an expression, it\ncan contain the current value, the index, and the `array`.\"\n      tags [ arrays language collections ]\n      references [\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\"]\n      examples [ (each number [ 1 2 3 ] (console.log number))\n                 (each (letter index) `[ a b c d ]\n                       (set letters letter index)\n                       (pipe letter (.to-upper-case) (console.log))) ])\n\n(macro each (item array ...body)\n       (var node this\n            args (if (node? item 'expression) item [item]))\n       `(|> @array\n            (.for-each (lambda @{ node& args& body& }))))\n\n\n(docs \"returns true if `haystack` includes `needle`.  `haystack` can be a string or array/list.\"\n      tags [arrays collections]\n      examples [ (includes? 'hello 'h) (includes? `[ Veni vidi vici] 'vidi) ])\n(macro includes? (haystack needle)\n       `(pipe @haystack (.index-of @needle) (!= -1)))\n\n(docs \"returns true if `haystack` does NOT include `needle`.\n`haystack` can be a string or array/list\"\n      tags [arrays collections]\n      examples [ (excludes? 'hello 10) (excludes? `[ Veni vidi vici] 'attenti) ])\n(macro excludes? (haystack needle)\n       `(pipe @haystack (.index-of @needle) (= -1)))\n\n","(namespace core)\n\n(macro quoted-hash (...pairs)\n     (var cached-quote-value sibilant.quote-hash-keys)\n     (set sibilant 'quote-hash-keys true)\n     (var value (^hash ...pairs))\n     (set sibilant 'quote-hash-keys cached-quote-value)\n     value)\n\n(docs \"this is the macro that is called by braces (`{}`). Produces a\njavascript object out of alternating key value pairs. To repeat an\nentry as both key and value, use the & character, as shown in examples.  To use the value of a variable as a key, use the backtick character before the key. These can be combined\"\n      tags [ collections objects ]\n      examples [ (hash k1 v1 k2 v2)\n                 (hash 'key 'value)\n                 { 'key { 'nested 'value } }\n                 { kv1& kv2& } { `variable 1 } { `variable & } ])\n      \n(macro hash (...pairs)\n       (assign pairs (pairs.map (#(p i)\n                                  (if (and (= p.token \"&\") (node? p 'special))\n                                      (do\n                                       (var double (get pairs (if (even? i) (+ 1 i) (- i 1))))\n                                       (if (and (node? double 'tick) (= double.token \"`\"))\n                                           (first double.contents)\n                                           double))\n                                      p))))\n                                                                                       \n       (when (odd? pairs.length)\n             (error (\"odd number of key-value pairs in hash: \"\n                     (call inspect pairs))))\n\n       (var {dynamic-keys static-keys}\n            (pairs.reduce (#(o item i)\n                            (if (and (even? i) (node? item 'tick) (= item.token \"`\"))\n                                (Object.assign {} o { dynamic-keys: [ ...o.dynamic-keys (first item.contents) ] })\n\n                                (and (odd? o.dynamic-keys.length) (odd? i))\n                                (Object.assign {} o { dynamic-keys: [ ...o.dynamic-keys item ] })\n\n                                (Object.assign {} o { static-keys: [ ...o.static-keys item ] })))\n                          { dynamic-keys: [], static-keys: [] }))\n\n       (var quote-keys sibilant.quote-hash-keys\n            pair-strings (bulk-map static-keys (#(key value)\n                                           [ (if (and quote-keys (not (node? key 'string)))\n                                                 [\"\\\"\" (transpile key) \"\\\"\"]\n                                                 (transpile key))\n                                             \": \"\n                                             (transpile value)])))\n\n       (if dynamic-keys.length\n           (do\n            (var symbol (generate-symbol 'hash))\n            `(*scoped-without-source\n              (var @symbol (hash ...@static-keys))\n              (set @symbol ...@dynamic-keys)\n              @symbol))\n\n        (>= 1 pair-strings.length)\n           [\"{ \" (interleave \", \" pair-strings) \" }\"]\n           [\"{\" (indent (interleave \",\\n\" pair-strings)) \"}\"]))\n\n\n(docs \"retreives object properties, potentially deeply. If more than one `keys` are provided,\n`get` fetches deeply into nested objects or arrays.\nWhen javascript dot notation can be used (`a.b = 3`), it is.\nOtherwise, bracket notation is used.\"\n      tags [collections objects]\n      examples [ (get an-object 'static-attribute-name)\n                 (get object dynamic-attribute-name)\n                 (get object \"these attributes\" \"can't be dotted\")\n                 (get array 0)\n                 (get object 'a 'b c)\n                 (get array 0 1 2) ])\n\n\n(macro get (obj ...keys)\n       [(transpile obj)\n         (map keys (#(key)\n                     (var transpiled (transpile key)\n                          output (output-formatter transpiled))\n\n                     (if (match-regex? output \"^\\\"[a-zA-Z0-9_]+\\\"$\")\n                         [\".\" (replace-all output \"\\\"\" \"\") ]\n                         [\"[\" transpiled \"]\"])))])\n\n(docs \"assigns object properties to `arr` in pairs, alternating between keys and values.\nWhen javascript dot notation can be used (`a.b = 3`), it is.  Otherwise, bracket notation is used\"\n      tags [collections objects]\n      examples [ (set an-object 'static-attribute-name 'value)\n                 (set object dynamic-attribute-name \"key name determined at runtime\")\n                 (set array 0 \"first element of array\")\n                 (set object \"can't be dotted\" 'value)\n                 (set object 'first-attribute 'first-value\n                      'second-attribute 'second-value) ])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))\n\n\n\n(docs \"returns the property names of `obj`.\"\n      tags [objects collections]\n      references: [ \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" ]\n      example (keys { a 1 b 2 }))\n(macro keys (obj)\n       '(Object.keys @obj))\n\n\n(docs \"uses the javascript delete keyword on any number of `objects`.\n      Use in conjunction with `get` or dotted literal notation (a.b).\"\n      tags [objects collections]\n      examples [ (delete object.a object.b)\n                 (delete (get object attribute) (get object \"other attribute\")) ])\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n\n(docs \"iterates over each attribute in `obj`\"\n      tags [objects collections]\n      example (each-key key { a 1 b 2 } (console.log key)))\n(macro each-key (as obj ...body)\n       `(pipe @obj (keys)\n              (.for-each (lambda @{ args: (if (node? as 'expression) as [as])\n                                    node: this }\n                                 ...@body))))\n","(namespace core)\n(docs \"inserts the result of each subsequent call in `calls` as the\nsecond argument to the next macro. This is very much akin to clojure's\nthread-first arrow or elixir's pipe operator.  Advanced: in order to\nthread the preceding topic into a position other than the second\nposition, use the character `#` to specify topic position\"\n      tags [language flow-control]\n      examples: [\n(pipe \"a b c d\"\n      .to-upper-case\n      (.replace \"A\" \"X\")\n      (.split \" \")\n      first\n      (concat \" marks the spot\"))\n\n(pipe \"{\\\"a\\\": {\\\"b\\\": [ 1, 2, 3 ]}}\"\n      JSON.parse\n      (get 'a)\n      JSON.stringify)\n\n(pipe 3 (+ 1) (var a #))\n]\n     references: [ \"https://clojuredocs.org/clojure.core/-%3E\"\n                   \"http://elixir-lang.org/docs/v1.0/elixir/Kernel.html#|>/2\" ])\n(macro pipe (...calls)\n       (inject undefined calls\n               (#(value item)\n                 (if (undefined? value) item\n                     (scoped\n                      (var cloned (if (node? item 'literal 'dots)\n                                      `(@item)\n                                      (clone item)))\n\n                      (var placeholder (detect cloned.contents\n                                               (#(node)\n                                                 (and (node? node 'other-char)\n                                                      (= \"#\" node.token))))\n                           placeholder-index (cloned.contents.index-of placeholder)\n\n                           placeholder-boundaries (if placeholder\n                                                      [ placeholder-index (+ 1 placeholder-index) ]\n                                                      [ 1 1 ]))\n\n                      (merge-into cloned\n                                  { contents [ ...(cloned.contents.slice 0 (first placeholder-boundaries))\n                                               value\n                                               ...(cloned.contents.slice (second placeholder-boundaries)) ] }))))))\n\n(alias-macro pipe |>)\n\n\n(docs \"most often called as its alias, `#->`, pipe-thunk applies a pipe chain to the argument of a function and returns the result\"\n      tags [functions language]\n      examples [ (.map `[ a b c ] (#-> (.to-upper-case) (concat \" is a letter\"))) ])\n(macro pipe-thunk (...calls) `(thunk @{ node this } (pipe #0 ...@calls)))\n(alias-macro pipe-thunk #->)\n\n\n(docs \"generates a function intended to be used in conjunction with\n`pipe` or `pipe-thunk` that does not interrupt the main flow of the\n`pipe`\"\n      tags [ language flow-control ]\n      examples [ (|> 2 (tap (+ 5) console.log) (* 10))\n                 (#-> .to-upper-case (tap console.log) (.split \" \")) ])\n(macro tap (thing ...body)\n       `((#> (|> #0 ...@body) #0) @thing))\n\n\n(macro distribute (thing macro ...alternatives)\n       `(@macro ...@(map alternatives (#(alt)\n                                        (if (node? alt 'expression)\n                                            `(|> @thing @alt)\n                                            `(|> @thing ...@alt))))))\n","(include \"../include/functional\")\n\n(def extract-options (config args)\n     (default args (process.argv.slice 2))\n     (var default-label 'unlabeled\n          current-label default-label\n          after-break false\n          config (or config {})\n          unlabeled [])\n\n     (def label? (item) (and (string? item) (.test (regex \"^-\") item)))\n\n     (def synonym-lookup (item)\n          (var config-entry (get config item))\n          (if (string? config-entry)\n              (synonym-lookup config-entry)\n              item))\n\n     (def takes-args? (item)\n          (!= false (get config (label-for item))))\n\n     (assign default-label (synonym-lookup default-label)\n             current-label default-label)\n\n     (def label-for (item)\n          (synonym-lookup (item.replace (regex \"^-+\") \"\")))\n\n     (def add-value (hash key value)\n          (var current-value (get hash key))\n          (when (undefined? current-value)\n                (assign current-value [])\n                (set hash key current-value))\n          (when (!= true value)\n                (current-value.push value)))\n\n     (def reset-label ()\n          (assign current-label default-label))\n\n     (inject {} args\n             (lambda (return-hash item index)\n                     (if (= \"--\" item) (assign after-break true)\n                         (if after-break\n                             (add-value return-hash 'after-break item)\n                             (if (label? item)\n                                 (do\n                                  (assign current-label (label-for item))\n                                  (add-value return-hash current-label true)\n                                  (when (not (takes-args? item)) (reset-label)))\n                                 (do\n                                  (add-value return-hash current-label item)\n                                  (reset-label)))))\n                     return-hash)))\n\n(def process-options (config)\n     (var options (extract-options config))\n     (when config\n           (def handle-pair (key value)\n                (var handle (get config key))\n                (when (string? handle) (handle-pair handle value))\n                (when (function? handle) (handle value options)))\n           (each (key) (keys options) (handle-pair key (get options key))))\n\n     options)\n\n(set module 'exports process-options)\n","(namespace core)\n(docs \"registers variables in `pairs` inside of the current scope using the javascript var keyword.\ndestructuring from arrays and objects is also supported, as shown in the examples. Note: `:` and `,` are always ignored.\"\n      tags [ variables language ]\n      examples: [ (var a)\n                  (var a: 1, b: 2)\n(var a [ 1 2 3 ]\n     [ b c d ] a)\n                  (var {attribute} { attribute: 'hi })\n                  (var {log dir} console)\n(var {a}: {a 1 b 2},\n     {c d}: {c 3 d 4})\n])\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \" (|> pairs\n                    destructure\n                    (map (#(pair) [(first pair) \" = \" (second pair)]))\n                    (interleave \",\\n    \")) ]))\n\n(docs \"registers constants in `pairs` inside of the current scope using the javascript const keyword.\ndestructuring from arrays and objects is also supported, as shown in the examples. Note: `:` and `,` are always ignored.\"\n      tags [ variables language ]\n      examples: [ (const a)\n                  (const a: 1, b: 2)\n(const a [ 1 2 3 ]\n     [ b c d ] a)\n                  (const {attribute} { attribute: 'hi })\n                  (const {log dir} console)\n(const {a}: {a 1 b 2},\n     {c d}: {c 3 d 4})\n])\n\n(macro const (...pairs)\n      (as-statement\n        [\"const \" (|> pairs\n                    destructure\n                    (map (#(pair) [(first pair) \" = \" (second pair)]))\n                    (interleave \",\\n    \")) ]))\n\n\n(docs \"assigns alternating keys and values in `args`.  This works much\nlike `var`, but without the var keyword.  It is important to\nunderstand variable scope in javascript in order to use this macro safely.\nThis macro supports destructuring, as shown in examples\"\n      tags [language variables]\n      examples [ (assign a 1)\n(assign a: 1, b: 2)\n(assign [ right left ] [ left right ])\n(assign {log} console)\n(assign [ a b ] c)\n(assign { a b } c\n        [ x y ] a)])\n\n(macro assign (...pairs)\n        (|> pairs\n            destructure\n            (map (#(pair) (as-statement [(first pair) \" = \" (second pair)])))\n            (interleave \"\\n\")))\n\n\n(docs \"sets default values for variables in current scope. `pairs` are\nalternating variable names and default values\"\n      tags [variables language]\n      example (default a 10 b 20))\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n","(namespace core)\n(docs \"returns true if the `string` matches `regexp`.  Deprecated in\n      preference to `.match` (`send` dot-invocation).\"\n      tags [regex strings]\n      example: (match? (regex \"^[a-z]+$\" 'i) 'word))\n(macro match? (regexp string)\n       '(.match @string @regexp))\n\n(docs \"similar to `match?` but builds a regex out of the `pattern` and `flags`.\"\n      tags [regex strings]\n      example (match-regex? 'word \"^[a-z]+$\" 'i))\n(macro match-regex? (string pattern flags)\n       '(match? (regex @pattern @flags) @string))\n\n\n(docs \"replaces the first occurance of `pattern` (as a regex) with `replacement`\"\n      tags [regex strings]\n      example: (replace \"hello world\" \"l+o\" \"y there,\"))\n(macro replace (string pattern replacement)\n       '(.replace @string\n              (regex @pattern)\n              @replacement))\n\n(docs \"replaces all occurrances of `pattern` (as a regex) with `replacement`\"\n      tags [regex strings]\n      example: (replace-all \"503-555-1212\" \"[0-9]\" \"#\"))\n(macro replace-all (string pattern replacement)\n       '(.replace @string (regex @pattern 'g) @replacement))\n\n(docs \"builds a regex using `pattern` and `flags` as arguments to the RegExp constructor\"\n      tags [regex]\n      examples [ (regex \"[0-9]+\") (regex \"0x[0-9a-f]+\" 'i)])\n(macro regex (pattern flags)\n       '(new RegExp @pattern @(or flags 'undefined)))\n\n","(namespace core)\n\n(macro statement! (node)\n     (if (empty-node? transpiled) undefined\n         [ node \";\" ]))\n\n\n(docs \"uses the javascript new keyword to construct an object using\n      `constructor`, with `args` passed as arguments to the constructor.\"\n      tags [functions]\n      example (new RegExp \"hello\" 'g))\n\n(macro new (constructor ...args)\n       [\"(new \" '(call @constructor ...@args) \")\"])\n\n(docs \"exposes the javascript typeof operator. most often, predicates\nsuch as `string?`, `function?`, `number?`, etc are preferred.\"\n      tags [type]\n      example: (typeof 5))\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n(docs \"inserts `contents` transpiled to javascript as a comment in the\noutput file, removing it from execution.\"\n      tags [language]\n      example (comment (scoped 1)))\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (pipe item transpile output-formatter\n                                                     (.replace (regex \"\\n\" 'g) \"\\n// \"))\n                                               null)))])))\n\n\n(docs \"outputs debug information about `arg`.  If `label` is\nomitted (only one argument is provided), the name of the variable or\nexpression of that first expression will be logged. Aliased as `pretty-log`\"\n      tags [language]\n      examples: [ (log-pretty 'my-label value)\n                  (log-pretty (+ 1 2)) ])\n(macro log-pretty (label arg)\n       (var node this)\n       (when (undefined? arg)\n             (assign arg label\n                     label [\"\\\"\" (prettify label false) \"\\\"\"]))\n       `(console.log (concat @[\"\\\"\" node.file \":\" node.line \"\\\"\"] \" \" @label \" = \" (prettify @arg))))\n(alias-macro log-pretty pretty-log)\n\n\n(docs \"throws a new javascript error with arguments as the string\"\n      tags [language]\n      example (throw (new Error \"could not find matching socks\")))\n\n(macro throw (error)\n       [\"throw \" (transpile error)])\n\n;;nodoc because this needs attention\n;;todo\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n         \"}).call(this)\"])\n\n(macro with-state (k v ...body)\n       (var {state} sibilant\n            [key value] (|> [ k v ] (map (#-> transpile output-formatter)))\n            before (get state key))\n       (set state key value)\n       (var return-value (interleave \"\\n\" (map body transpile)))\n       (set state key before)\n       return-value)\n\n(docs \"combines elements of array `arr` into a string, inserting\n`glue` string between each element.  if `glue` is omitted (only one\nargument provided), the elements of `arr` are joined with an empty\nstring\"\n\n      tags [arrays collections strings]\n      examples [ (join `[ a few words ]  \", \" )\n                 (join `[ several more words ]) ])\n\n(macro join (arr glue)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       `(.join @arr @(or glue \"\\\"\\\"\")))\n\n(macro parens (...contents)\n       [\"(\" ...contents \")\"])\n\n(docs \"inserts a pragma for source-mapping-url\"\n      tags []\n      example (source-mapping-url \"/example.map\"))\n\n(macro source-mapping-url (url)\n       [ \"//# sourceMappingURL=\" (|> url transpile output-formatter eval) \"\\n\" ])\n\n(macro require! (...requires)\n       `(var ...@(inject [] requires\n                         (#(pairs node)\n                            (pairs.concat\n                             (if\n\n                              (and (even? pairs.length)\n                                   (node? node 'tick 'string))\n                              \n                              [ (merge-into (clone node)\n                                            { token (|> node transpile output-formatter (.slice 1 -1))\n                                              contents []\n                                              type 'literal })\n                                `(require @node) ]\n\n                                 (odd? pairs.length)\n                                 [ `(require @node) ]\n\n                                 [ node ]))))))\n\n\n(macro export (...local-vars)\n       (var pairs (local-vars.reduce\n                   (#(acc value) (acc.concat [(^core/quote value) value]))\n                   []))\n       `(set exports ...@pairs))\n\n(macro empty-list () 'null)\n\n\n(macro debug (val)\n     (set sibilant 'debug (eval (output-formatter (transpile val)))) null)\n\n\n(macro dots (...contents)\n       (transpile contents))\n\n(docs \"loads and transpiles content from another file or `files` as if\nit were written in-line.  This is distinct from node's `require`\nfunction, as `include` will drop the output javascript directly in\nplace of the include statement.  Namespaced macros defined in the\nincluded file will not by default be imported into the current macro\nnamespace.  Include will append \\\".sibilant\\\" to the end of files, and\nwill also use node's module system to resolve sibilant files from\nother packages.  As a noncompiling example, it is possible to `npm\ninstall sibilant-react` and `(include \\\"sibilant-react/macros\\\")`,\nwhich introduces the `react` macro namespace.\"\n      tags [language])\n\n(macro include (...files)\n     (pipe files\n           (.map (#(file)\n                   (sibilant.with-default-search-path\n                    (#>\n                     (pipe file\n                           transpile\n                           output-formatter\n                           eval\n                           sibilant.include)))))\n           (interleave \"\\n\")))\n\n"]}